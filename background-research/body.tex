\section{Overview}

aaa

\section{Value/Importance/Impact}

aaa

\section{Similar work}

aaa

\subsection{Alda}

aaa

\subsection{Chuck}

aaa

\subsection{Overtone}

Overtone is an Open Source toolkit for designing synthesizers and collaborating with music. It provides\cite{Aaron16}:
\begin{itemize}
\item A Clojure API to the SuperCollider synthesis engine
\item A growing library of musical functions (scales, chords, rhythms, arpeggiators, etc.)
\item Metronome and timing system to support live-programming and sequencing
\item Plug and play MIDI device I/O
\item A full Open Sound Control (OSC) client and server implementation.
\item Pre-cache - a system for locally caching external assets such as .wav files
\item An API for querying and fetching sounds from http://freesound.org
\item A global concurrent event stream
\end{itemize}

Overtone's idea is about sound generation. "Let me answer from the synthesis perspective - which is one of my main interests. Learning to design new synthesisers is a pretty dark art, and most of the books/resources I found take a very theory-centric stance which I found to not be particularly useful." Said the author of Overtone, Sam Aaron.\cite{Aaron13}

Another advantage of overtone is about collaborative programming, so people can write music together.

From a language design perspective, Sam Aaron describes the design of Overtone as follows:
\begin{itemize}
\item Synths are trees of ugens. Ugens are standard Clojure functions and return data-structures which are understood by the macros demo and defsynth. You can pass arguments to the ugen functions to specify their behaviour.
\item Synths are not ugens. Calling a ugen function returns a data structure which can be used in a synth design. Calling a synth as a function triggers (i.e. plays) that synth.
\end{itemize}


\section{Potential Project}

\subsection{Features}
\subsection{Concrete Syntax}
\subsection{Parse into AST}
\subsection{Compiler}

\section{Conclusions}

This paragraph will end the body of this sample document.
