\section{Overview}

Music is one of the most beautiful and ancient languages humans have created. With the advancement of technology, many solutions have been designed to facilitate the creation and spread process of music. ABC is one of the most widely used music notation forms. Even though it has great features to help musicians generate formal music sheets from scratch, its nature of being a markup language has limited its capacity for effective modification.

Many works have been done to enable musicians to systematically and efficiently generate and modify scores. However, most existing programming tools are either insufficient or not convenient to use with ABC. Our group plans to design a domain specific language called ABCD that extends ABC with common programming language features such as variables, functions, conditionals and loops. Our goal is to allow users to efficiently modify an existing ABC file or create a new piece by writing scripts in ABCD that compiles to ABC.

\section{Background and Significance}

ABC music notation is a markup language for sheet music, designed to be comprehensible by both computers and humans. It uses letters, digits and symbols to represent various music features, such notes, meters, accents, etc., allowing users to type out tunes on a computer without using the special musical characters\cite{Walshaw11}.

ABC was originally invented for sharing a large amount of tunes in a small-size file through email\cite{Johnson17}. The development of different ABC software editors also offer many other advantages, such as transposition and file conversion. ABC could be useful for training one's ears and sight-reading skills. People with limited music education often find it easier to read in ABC\cite{Mary14}. 

Nonetheless, since ABC is originally designed for simple tunes, there are many limitations in handling complex music pieces, which make it difficult for musicians to represent certain features or apply certain changes to an existing piece. Some limitations are associated with the parser. The parser cannot tell from the data format what types of ABC extension of rarely-used features it may encounter, and there is no formal specification for the parser to know when the chain of elements would end\cite{Cuthbert14}. ABC cannot express many of the musical features. For instance, there is little support for nested tuples, bar numbering control, and grace notes positioningend\cite{Cuthbert14}. Only a subset of guitar chords have semantic meaning in ABC\cite{Chambers02}. There is no efficient search function to find multiple occurrences of a tune pattern or a chord. As a result, users cannot systematically change a note in the multiple occurrences of a particular chord. 

In general, using a computer program to make music has the following significance. It is faster, more reusable, and less prone to mistakes if the algorithms in a musician's mind can be represented by computer algorithms. A music composer may use programs to realize imagined and novel music thatâ€™s unperformable by humans or that requires an amount of calculations unthinkable without a computer. By defining different functions, one may enhance a composer or an instrumentalist's operations in many ways\cite{Dobrian88}. Similarly, the motivation of this project is to expand and empower ABC so that users can perform operations more effectively by programming in ABCD. An example would be to add a notes to multiple occurrences of a tune pattern at the same time.  Since ABCD would eventually be compiled into ABC, it is not our intention to resolve the limitations related to the design of the ABC language itself, such as changing the parser, or add new symbols in ABC so that it can represent more chords. 
 


\section{Similar work}

aaa

\subsection{Alda}

aaa

\subsection{Chuck}

	\subsubsection{What is it about?}

	Chuck is a powerful programming language designed for real-time sound synthesis and music creation\cite{WangCook02}.  It has the following great features\cite{Wang08}:
	\begin{itemize}
	\item Strongly-timed: Chuck allows programmers to control and reason about time precisely and expressively. It is an extremely important feature in audio programming paradigm.
	\item Deterministic concurrency model: Chuck is able to run multiple processes (shreds) in parallel in its virtual machine. Combined with time-based model, it empowers end-user programmers to have arbitrarily fine granularity and create complex audio synthesis programs. 
	\item Dynamic control rates: Programmers can manipulate the control rates (the manner with which a shred advances its way through time\cite{Wang08}) as they want and the control rates can dynamically vary with time.
	\item Live-coding:  Chuck allows programmers to modify the code on the fly without recompiling.
	\end{itemize}

	\subsubsection{What has it achieved?}
		\paragraph{Language Design:}
			Chuck is first released in 2003\cite{Wang15}. Since then, it has evolved into a very robust and complete audio programming language. It is static typing. Besides, the designer of Chuck has includes most of the modern language features in this languages. For example, it has primitive types such as int, float, void etc, reference types, variables, arrays, functions, control structures, and even object oriented features. Furthermore, since Chuck is a programming language specialized in music, it contains many special designs such as `time` and `dur` type for users to easily manipulate time, `unit generator` and `unit analyzer` functions that are convenient to modify big chunk of music.
		\paragraph{Applications:}
			The Chuck has found a variety of applications in music research and music creation. First of all, it is able to turn computers into instruments. Chuck has powered two "computer music" orchestras, namely PLOrk (Princeton Laptop Orchesta) and SLOrk (Stanford Laptop Orchestra). Besides, Chuck has served as experimental platformfor on-the-fly machine learning for real-time musicinformation retrieval prototyping\cite{Wang15}. In addition, it has also been applied in the development of music mobile-apps like Ocarina and Smule\cite{Wang15}.
	\subsubsection{How our language is different?}
	
		The success of Chuck demonstrates the significance of the role of programming language plays in music and audio produciton. Designing and applying programming lanuages in generating and modifying music is definitely a valuable task to do. And Chuck is a great example we can learn from when designing our own Domain Specific Language which is customized for ABC music notation. There are many language designs in Chuck that we can follow. For instance, we should definitely include primitive types such as int, float, and music specific types like duration, note etc. Moreover, having functions and common control structures like conditional statements and loops will also be helpful. With that being said, we will not copy all the features from Chuck into ABCD. What we will do differently is that ABCD will contain ABC related data types to natively support ABC notations. Besides, we will also provide build-in SDK to systematically modify ABC files. 

\subsection{Overtone}

Overtone is an Open Source toolkit for designing synthesizers and collaborating with music. It provides\cite{Aaron16}:
\begin{itemize}
\item A Clojure API to the SuperCollider synthesis engine
\item A growing library of musical functions (scales, chords, rhythms, arpeggiators, etc.)
\item Metronome and timing system to support live-programming and sequencing
\item Plug and play MIDI device I/O
\item A full Open Sound Control (OSC) client and server implementation.
\item Pre-cache - a system for locally caching external assets such as .wav files
\end{itemize}

Overtone's idea is about sound generation. "Let me answer from the synthesis perspective - which is one of my main interests. Learning to design new synthesisers is a pretty dark art, and most of the books/resources I found take a very theory-centric stance which I found to not be particularly useful." Said the author of Overtone, Sam Aaron\cite{Aaron13}. The current design of ABCD is just let it compile to ABC, and let ABC deals with the sound generation part. The ultimate version of ABCD can be directly interpreted to play sound, so how Overtone hooks up with SuperCollider can be case-studied for our own implementation.

Another advantage of overtone is about collaborative programming. Overtone provides an API for querying and fetching sounds from http://freesopund.org and a global concurrent event stream\cite{Aaron16}. Sharing music is a huge part of enable people to write music. ABC is a great source in text format to share music, and Overtone is a great source to share music in computer programs. However, to understand Overtone program is not as straight forward as reading ABC notation. ABCD will have programming feature, so we enable both sides --- for people who writes complicated music programs and for people who just write plain ABC with some syntactic sugar to make their life easier.

From a language design perspective, Overtones design is based on Clojure. Two core component of Overtone are synths and ugens(unit-generator). Synths are trees of ugens. Ugens are standard Clojure functions and return data-structures which are understood by the macros demo and defsynth. You can pass arguments to the ugen functions to specify their behaviour. Synths are not ugens. Calling a ugen function returns a data structure which can be used in a synth design. Calling a synth as a function triggers (i.e. plays) that synth.\cite{Aaron14} The story of overtone gives us some hints on the language design --- we probably need to define what are the automics in the music world and make them first-class members of our language. However, for a sequence of sounds, they are probably playable/translatable objects.


\section{Potential Project}

\subsection{Features}
	\subsubsection{Variables:}
	\subsubsection{Functions:}
	Functions are a basic component of a programming language for performing a specific task. ABCD would support users to write functions such as (but not limited to) the following:

	- A function that takes a temperament and change it to a different temperament.

 	- A function that takes a whole music score and output the bar numbers along with the piece.
 	
	- A function that takes a note "n" and a chord "c", and randomly generate another note "n2" according to the "c", to harmonize "n".
	  It may also support first-class functions. For instance, if a user wishes to change all 3/4 bars containing a certain note pattern to 4/4 by adding a rest to the end, there needs to be a search function which takes a function (a conditional in this case) as its predicate or search criterion. 

	\subsubsection{Loops:}
	All high-level programming languages provide different forms of loop for the purpose of executing one or more statements up to a desired number of times. In the domain of music, it would be useful for performing search, systematic insertion, modification, and generation of music. 

	Imagine a musician is trying to perform the following operation: search for all occurrences of tune "GFERE2" and return their bar numbers. One can easily use a loop to iterate through all the bars or movements (depending on what the variable is) of a piece. This operation may be useful when a musician needs to change a note in some occurrences of a same pattern, but she has to examine the context of those occurrences first. One may think "Ctrl+F" would simply do the job, but ironically, it's not even supported in the most popular ABC editor\cite{SlashdotMedia17}.  

	Another example is to generate a sequence of semi-tone of length 30. Instead of manually typing 30 notes, one can simply use loop to generate a scale by increasing the key by half in each iteration.

	\subsubsection{Conditions:}
		
	\subsubsection{Import Statement:}
\subsection{Concrete Syntax}
We will design concrete syntax for ABCD to support the following features: variables, conditionals functions, loops, and import statements.
\subsection{Parse into AST}

After some research, we have found a few implmentations of parsing ABC. Sergi Mansilla has implemented an ABC parser in JavaScript, which parses the ABC notation to a JSON object\cite{Mansilla12}. Remo Dentato has developed a C library to parse the ABC notation\cite{Dentato09}, however, the source code can no longer be found on the website and the usage description is quite complicated. However, on Dentato's website, it offers some high-level design graph of the scanner and documentation on tokens. Hans H\"{o}glund has implemented a parser in Haskell\cite{Hoglund15}. H\"{o}glund's implmentation has a few limitations such as do not support volatile features, text strings, and macros. abc4j is a Java library that provides API to handle ABC music notation using Java. The source code can be downloaded on \url{https://code.google.com/archive/p/abc4j/source}. However, it only supports the v1.6 standard of ABC (the current version is v2.1). There are many other people who tried to implment parser for ABC but failed or stopped their project.

Mansilla's implmentation seems to be the easiest one to comprehend and can be adopted effortlessly if we implment ABCD language in JavaScript. The parser is based on PEG.js(parsing expression grammar), a simple parser generator for JavaScript that produces fast parsers with error reporting\cite{Ryuu17}. It integrates both lexical and syntactical analysis. The parsing expression grammar formalism is described to be more powerful than traditional LL(k) and LR(k) parsers.

In order to build a prototype, we think of a simple implementation in Python that only parses a subset of ABC notation(bars, title, etc.), because Python is good for its string manipulation capabilitites. In our full project, we plan to use a parser generator to completetly contain the whole ABC language specification. 

For example, for the following ABC code.
\begin{verbatim}
X:1
T:Notes
M:C
L:1/4
K:C
C, D, E, F,|G, A, B, C|D E F G|A B c d\
|e f g a|b c' d' e'|f' g' a' b'|]
\end{verbatim}

We will parse it to an AST like this:
\begin{verbatim}
{
	id: 1,
	title: "Notes",
	meter: "C",
	length: "1/4",
	key: "C",
	tune: [ // tune is an array of bars
	    [{ note: "C",
	       length: 1},
	     { note: "D",
	       length: 1},
	     { note: "E",
	       length: 1},
	     { note: "F",
	       length: 1},],
	    [{ note: "G",
	       length: 1},
	     { note: "A",
	       length: 1},
	     { note: "B",
	       length: 1},
	     { note: "C",
	       length: 1},],
	       ...
	    [{ note: "f'",
	       length: 1},
	     { note: "g'",
	       length: 1},
	     { note: "a'",
	       length: 1},
	     { note: "b'",
	       length: 1},],
	]
}
\end{verbatim}

\subsection{Compiler}

\section{Conclusions}

This paragraph will end the body of this sample document.